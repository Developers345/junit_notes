# Nested Tests

We can categorize or group test methods into **nested classes** based on the type of functionality or testing being applied. This helps in clearly identifying which group of tests is failing and at what percentage by looking at the test report generated by test engines.

```java
class UserAccountService {
    void registerUser(UserAccount userAccount) {
        // age qualified
        // emailAddress should be valid
        // mobileNumber should be valid

        // both emailAddress and mobileNumber should not be existing
        // user should not be disabled/locked
    }
}
````

```java
class UserAccountServiceTest {

    @Nested
    class NewUserAccountRegistrationTest {
        void testRegisterUser() {}
        void testRegisterUserWithAgeNotValid() {}
        void testRegisterUserWithEmailAddressNotValid() {}
        void testRegisterUserWithMobileNoNotValid() {}
    }

    @Nested
    class ExistingUserAccountRegistrationTest {
        void testRegisterUserWithExistingUser() {}
        void testRegisterUserWithExistingUserDisabled() {}
        void testRegisterUserWithExistingUserLocked() {}
        void testRegisterUserWithEmailAddressExists() {}
        void testRegisterUserWithMobileNumberExists() {}
    }
}
```

---

# Full Example of Nested Tests

## Original Class

### UserAccount.java

```java
package com.bu5.beans.nested;

import lombok.Builder;
import lombok.Data;

@Data
@Builder(builderMethodName = "of")
public class UserAccount {

    private int id;
    private int age;
    private String emailAddress;
    private String mobileNumber;
}
```

---

### UserRegistrationException.java

```java
package com.bu5.beans.nested;

public class UserRegistrationException extends RuntimeException {

    public UserRegistrationException(String message) {
        super(message);
    }
}
```

---

### UserAccountService.java

```java
package com.bu5.beans.nested;

import java.security.SecureRandom;
import java.util.Collections;
import java.util.Map;

public class UserAccountService {

    private final Map<Integer, UserAccount> userAccountDb =
            Collections.singletonMap(1,
                    UserAccount.of()
                            .id(1)
                            .age(32)
                            .emailAddress("john@gmail.com")
                            .mobileNumber("9632587458")
                            .build()
            );

    public int registerUser(final UserAccount userAccount) {
        int id;

        if (userAccount.getAge() < 18) {
            throw new UserRegistrationException("age is invaild");
        }

        if (userAccount.getMobileNumber() == null ||
            userAccount.getMobileNumber().trim().length() < 10) {
            throw new UserRegistrationException("mobileNumber is not valid");
        }

        if (userAccount.getEmailAddress() == null ||
            !userAccount.getEmailAddress().contains("@")) {
            throw new UserRegistrationException("emailAddress is not valid");
        }

        userAccountDb.forEach((inId, inUserAccount) -> {

            if (userAccount.getMobileNumber()
                    .equals(inUserAccount.getMobileNumber())) {
                throw new UserRegistrationException("mobileNumber already exists");
            }

            if (userAccount.getEmailAddress()
                    .equals(inUserAccount.getEmailAddress())) {
                throw new UserRegistrationException("emailAddress already exists");
            }
        });

        id = new SecureRandom().nextInt();
        return id;
    }
}
```

---

## Test Class

### UserAccountServiceTest.java

```java
package com.bu5.beans.nested;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class UserAccountServiceTest {

    UserAccountService userAccountService = null;

    @BeforeEach
    public void setUp() {
        userAccountService = new UserAccountService();
    }

    @Nested
    class NewUserAccountRegisterationTest {

        @Test
        void testRegisterUser() {
            UserAccount userAccount = UserAccount.of()
                    .age(24)
                    .mobileNumber("1234567890")
                    .emailAddress("peter@gmail.com")
                    .build();

            int actualUserId = userAccountService.registerUser(userAccount);
            assertTrue(actualUserId > 0);
        }

        @Test
        void testRegisterUserWithInvalidMobileNumber() {
            UserAccount userAccount = UserAccount.of()
                    .age(24)
                    .mobileNumber("123456789")
                    .emailAddress("peter@gmail.com")
                    .build();

            assertThrows(UserRegistrationException.class, () -> {
                userAccountService.registerUser(userAccount);
            }, "mobileNumber is not valid");
        }

        @Test
        void testRegisterUserWithInvalidAge() {
            UserAccount userAccount = UserAccount.of()
                    .age(6)
                    .mobileNumber("1234567890")
                    .emailAddress("peter@gmail.com")
                    .build();

            assertThrows(UserRegistrationException.class, () -> {
                userAccountService.registerUser(userAccount);
            }, "age is invaild");
        }

        @Test
        void testRegisterUserWithInvalidEmailAddress() {
            UserAccount userAccount = UserAccount.of()
                    .age(26)
                    .mobileNumber("1234567890")
                    .emailAddress("peter=gmail.com")
                    .build();

            assertThrows(UserRegistrationException.class, () -> {
                userAccountService.registerUser(userAccount);
            }, "emailAddress is not valid");
        }
    }

    @Nested
    class ExistingUserAccountRegistrationTest {

        @Test
        void testRegisterExistingUserWithEmailAddress() {
            UserAccount userAccount = UserAccount.of()
                    .age(26)
                    .mobileNumber("1234567890")
                    .emailAddress("john@gmail.com")
                    .build();

            assertThrows(UserRegistrationException.class, () -> {
                userAccountService.registerUser(userAccount);
            }, "emailAddress already exists");
        }

        @Test
        void testRegisterExistingUserWithMobileNumber() {
            UserAccount userAccount = UserAccount.of()
                    .age(26)
                    .mobileNumber("9632587458")
                    .emailAddress("john1@gmail.com")
                    .build();

            assertThrows(UserRegistrationException.class, () -> {
                userAccountService.registerUser(userAccount);
            }, "mobileNumber already exists");
        }
    }

    @AfterEach
    public void cleanUp() {
        userAccountService = null;
    }
}
```

---

## Output

<img width="1727" height="600" alt="Screenshot 2026-01-24 115616" src="https://github.com/user-attachments/assets/6578a083-e66d-4e11-a0c8-a7d3e5a05d4a" />

